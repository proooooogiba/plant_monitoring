\documentclass{bmstu}
\addbibresource{main.bib} %Import the bibliography file
\usepackage{hyperref}

\begin{document}

    \makecourseworktitle
    {Информатика, искусственный интеллект и системы управления} % Название факультета
    {Компьютерные системы и сети} % Название кафедры
    {Система мониторинга состояния комнатного растения} % Тема работы
    {Погиба~И.~О./ИУ6-74Б} % Номер группы/ФИО студента (если авторов несколько, их необходимо разделить запятой)
    {Хохлов~С.~А.} % ФИО научного руководителя
    {} % ФИО консультанта (необязательный аргумент; если консультантов несколько, их необходимо разделить запятой)

    \chapter*{РЕФЕРАТ}
    \addcontentsline{toc}{chapter}{РЕФЕРАТ}

    МИКРОКОНТРОЛЛЕР, ESP-32, DHT-11, YL-69, HCSR-04, TEMT6000, MQTT, PROMETHEUS, GRAFANA

    Объектом разработки данной курсовой работы является система мониторинга состояния за комнатным растением.

    Цель работы – закрепление знаний, полученных при изучении дисциплины «Микропроцессорные системы», в процессе самостоятельной работы при проектировании устройства для контроля работы электроприборов; развитие навыков и умений применять теоретические знания на практике при выполнении учебных проектов, а также по заказам промышленности и в порядке личной инициативы; освоение новых технологий проектирования при выполнении проектных работ.

    В процессе выполнения курсового проекта были решены следующие задачи: анализ задания, выбор схемотехнического решения и элементов системы, анализ и выбор радиоэлементов схемы, расчет потребляемой мощности устройства, разработка алгоритмов управления и соответствующей программы микроконтроллера.

    В результате было спроектировано требуемое устройства и получена сопутствующая документация, а именно: функциональная и принципиальная схемы, схемы алгоритмов управления и соответствующая программа микроконтроллера.
    Репозиторий со всеми исходными файлами находится по \href{https://github.com/proooooogiba/plant_monitoring}{ссылке}, доступ к метрикам растения по \href{http://vm4481772.25ssd.had.wf:3000/d/ce3f4anwhavpce/plant-monitoring?from=now-5m&to=now&timezone=browser}{ссылке}.


    \begin{abbreviations}
        \definition{МК}{микроконтроллер}
        \definition{ESP32}{используемый микроконтроллер}
        \definition{DHT-11}{датчик температуры и влажности почвы}
        \definition{YL-69}{датчик влажности почвы}
        \definition{HCSR-04}{ультразвуковой датчик, вычисляющий расстояние до объекта}
        \definition{TEMT6000}{датчик интенсивности света}
        \definition{MQTT}{легковесный протокол обмена сообщениями для публикации/подписки сообщений}
        \definition{Алерт}{механизм, который позволяет отслеживать состояние системы и уведомлять о проблемах}
        \definition{PROMETHEUS}{база данных временных рядов, которая поддерживает сбор данных из различных источников посредством экспортеров}
        \definition{GRAFANA}{система визуализации и анализа информации, которая позволяет  работать с широким спектром источников данных}
        \definition{ПЭВМ}{персональная электронно-вычислительная машина }
    \end{abbreviations}

    \maketableofcontents

    \chapter*{ВВЕДЕНИЕ}
    \addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}
    Курсовой проект «Система мониторинга состояния комнатного растения» выполнялся на основании учебного плана кафедры ИУ6.

    Цель данной курсовой работы – формировании навыков разработки и проектирования микропроцессорных систем путём освоения современных технологий проектирования систем на основе микроконтроллеров, а также программируемых систем на кристалле.

    Проектирование контрольно-измерительного устройства состоит из двух основных частей: конструкторская часть и технологическая часть.
    Конструкторская часть включает в себя:
    \begin{itemize}
        \item[-] описание архитектуры и технические характеристики использованного в проекте микроконтроллера;
        \item[-] описание разработанной структурной и функциональной схемы микроконтроллерной системы;
        \item[-] описание принципиальной электрической схемы МК-системы с обоснованием выбора используемых радиоэлементов;
        \item[-] назначение функциональных элементов микроконтроллерной системы с описанием принципов работы используемых модулей микроконтроллера, а также других системных устройств;
        \item[-] описание алгоритмов функционирования МК-системы;
        \item[-] описание алгоритмов функционирования МК-системы;
        \item[-] расчет потребляемой мощности устройства.
    \end{itemize}

    Технологическая часть включает в себя:
    \begin{itemize}
        \item[-] характеристику использованных систем разработки и отладки программ;
        \item[-] тестирование и отладку программы;
        \item[-] описание и моделирование работы системы;
        \item[-] описание способа программирования МК.
    \end{itemize}

    По завершении проектирования была выполнена проверка работоспособности схемы и программного обеспечения.


    \chapter{Конструкторская часть}
    \section{Анализ требований}
    Согласно техническому заданию, необходимо разработать на основе микроконтроллера ESP32 систему мониторинга за комнатным растением, охватывающую показатели температуры и влажности воздуха, влажности почвы, интенсивность света, рост растения. Необходимо предусмотреть  отправку данных о состоянии растения на сервер и отслеживание показателей с использованием временных рядов. Спроектировать и реализовать общую оценку состояния комнатного растения.

    Основанием для выполнения данной работы являются:
    \begin{itemize}
        \item[-] учебный план кафедры ИУ6;
        \item[-] задание на курсовой проект;
    \end{itemize}

    В результате анализа требований к микроконтроллерной системе, можно сформулировать перечень блоков, которые необходимы для реализации устройства:
    \begin{itemize}
        \item[-] микроконтроллер;
        \item[-] программатор;
        \item[-] датчик расстояния;
        \item[-] датчик освещённости;
        \item[-] датчик температуры и влажности;
        \item[-] датчик влажности почвы;
        \item[-] датчик освещённости;
        \item[-] блок связи с ПЭВМ;
    \end{itemize}

    \includeimage
    {Struct_scheme} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
    {f} % Обтекание (без обтекания)
    {h} % Положение рисунка (см. figure из пакета float)
    {0.66\textwidth} % Ширина рисунка
    {Структурная диаграмма} % Подпись рисунка

    \section{Архитекутра проекта}\label{sec:arch}
    Алгоритм работы ситсемы мониторинга за комнатным растение (см. рисунок ~\ref{img:architecture}):
    \begin{enumerate}
        \item микроконтроллер снимает показания с датчиков по соответствующим портам GPIO
        \item микроконтроллер с помощью встроенного Wi-Fi модуля отправляет эти метрики в формате JSON по протоколу mqtt \cite{MQTTStandardIoT} на сервер
        \item на сервере с помощью утилиты mqtt-exporter \cite{KpetremannMqttexporterSimple} метрики экспортируются в prometheus \cite{OverviewPrometheus}
        \item prometheus используется в качестве источника данных в grafana \cite{GrafanaOSSEnterprise} и таким образом метрики появляются на борде
    \end{enumerate}

    \includeimage
    {architecture} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
    {f} % Обтекание (без обтекания)
    {h} % Положение рисунка (см. figure из пакета float)
    {1\textwidth} % Ширина рисунка
    {Архитектура проекта "Система мониторинга за комнатным растением"} % Подпись рисунка

    \section{Дифференцированная оценка состояния растения}\label{sec:diff-plant-estimate}
    Для оценки состояния растения были выбраны следующие, получаемые метрики:

    Определение общего состояния комнатного является дифференцированной оценкой,
    основанная на таких показателях, как:
    \begin{itemize}
        \item температура воздуха
        \item влажность воздуха
        \item влажность почвы
        \item освещённость
    \end{itemize}

    Для оценки состояния растения на основе указанных метрик можно использовать
    формулу, учитывающую оптимальные диапазоны для каждой метрики.
    \begin{enumerate}
        \item Определение оптимальных диапазонов (оптимум)
        \begin{itemize}
            \item температура воздуха: 20--25°C
            \item влажность воздуха: 40--60%
            \item влажность почвы: 30--50%
            \item освещённость: 200--800 люкс
        \end{itemize}
        \item Нормализация значений.
        Каждую метрику можно нормализовать в диапазоне от 0 до 1:
        \begin{gather*}
            \text{Температура} = \frac{\text{Текущая температура} - 20}{25 - 20}\\
            \text{Влажность воздуха}= \frac{\text{Текущая влажность} - 40}{60 - 40}\\
            \text{Влажность почвы}= \frac{\text{Текущая влажность почвы} - 30}{50 - 30}\\
            \text{Освещённость}= \frac{\text{Текущая освещённость} - 200}{800 - 200}\\
        \end{gather*}
        \item Формула для оценки состояния.
        Зададим равные веса для каждой метрики, так как считаем, что метрики равнозначны.

            {\small
        $\text{Состояние растения} = \frac{\text{Температура} + \text{Влажность воздуха} + \text{Влажность почвы} + \text{Освещённость}}{4} \times 100$
        }
    \end{enumerate}

    \section{Проектирование функциональной схемы}
    При разработке МК-системы был выбран микроконтроллер ESP32. Функциональная схема микроконтроллера ESP32 приведена на рисунке ~\ref{img:Function Block}.

    ESP32 основан на двухъядерном процессоре с архитектурой Xtensa, который имеет 32 рабочих регистра общего назначения. Каждый из регистров напрямую подключен к АЛУ, что позволяет выполнять операции с двумя регистрами за один такт.

    В состав ESP32 входят: 4 МБ встроенной флэш-памяти, 520 кбайт статического ОЗУ(16 кбайт для кэша), 448 кбайт ПЗУ, поддержка внешней памяти через интерфейс SPI, до 34 линий ввода-вывода, два универсальных таймера, аппаратный модуль для работы с Wi-Fi и Bluetooth, несколько интерфейсов для связи (UART, I2C, SPI), а также встроенные функции для работы с прерываниями. Процессор поддерживает различные режимы энергосбережения, что позволяет оптимизировать потребление энергии в зависимости от задач. В программной памяти реализована конвейеризация, что обеспечивает высокую производительность за счет предварительной загрузки инструкций.

    \includeimage
    {Function_Block} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
    {f} % Обтекание (без обтекания)
    {h} % Положение рисунка (см. figure из пакета float)
    {0.66\textwidth} % Ширина рисунка
    {Функциональная схема ESP32} % Подпись рисунка

    \subsection{Организация блока Wi-Fi модуля в ESP32}

    Блок Wi-Fi модуля ESP32 обеспечивает беспроводную связь и поддерживает различные режимы работы, включая режим STA (Station) и AP(acess point).

    Wi-Fi модуль ESP32 включает в себя несколько ключевых компонентов:
    \begin{enumerate}
        \item RF-часть - отвечает за передачу и прием радиосигналов;
        \item MAC-уровень - управляет доступом к среде передачи и обработкой данных;
        \item Программное обеспечение - реализует стек протоколов, включая TCP/IP.
    \end{enumerate}

    ESP32 использует Non-Volatile Memory (NVM) для хранения конфигурационных данных, что позволяет сохранять настройки даже при отключении питания. В NVM хранятся следующие данные:
    \begin{itemize}
        \item[-] SSID и пароль для подключения к Wi-Fi сети;
        \item[-] Настройки безопасности (например, тип шифрования);
        \item[-] Параметры сети (IP-адрес, маска подсети, шлюз).
    \end{itemize}

    \subsubsection{Режим работы STA}
    Режим STA (Station) позволяет ESP32 подключаться к существующей Wi-Fi сети. В этом режиме микроконтроллер функционирует как клиент, который может обмениваться данными с сервером или другими устройствами в сети.
    Основные этапы работы в режиме STA:
    \begin{enumerate}
        \item Сканирование сетей - ESP32 ищет доступные Wi-Fi сети и выбирает нужную;
        \item Подключение - после выбора сети происходит аутентификация с использованием SSID и пароля, хранящихся в NVM;
        \item Получение IP-адреса - после успешного подключения ESP32 запрашивает IP-адрес через DHCP или использует статическую конфигурацию.
    \end{enumerate}

    \subsubsection{Режим работы AP}
    Режим Access Point (AP) позволяет ESP32 функционировать как точка доступа, к которой могут подключаться другие устройства. В этом режиме ESP32 создает собственную Wi-Fi сеть, предоставляя возможность подключения к ней.

    Основные этапы работы в режиме AP:
    \begin{enumerate}
        \item Создание сети - ESP32 инициализирует Wi-Fi модуль и создает сеть с заданным SSID и паролем;
        \item Настройка параметров - можно настроить параметры безопасности, такие как тип шифрования (WPA2, WPA, открытая сеть);
        \item Подключение клиентов - другие устройства могут подключаться к созданной сети, используя указанные SSID и пароль.
        \item Обмен данными - после подключения клиенты могут обмениваться данными с ESP32, который может выступать в роли сервера, обрабатывая запросы и отправляя ответы
    \end{enumerate}


    \subsection{Распределение портов}
    МК ESP32 имеет 34 вывода общего назначения (GPIO), которые могут использоваться для различных функций. Из них 15 выводов могут быть использованы для аналогового ввода (ADC), а также поддерживают функции PWM, I2C, SPI и UART.
    . Выводы микроконтроллера ESP32 показаны на рисунке ~\ref{img:esp32_pinout}.

    \includeimage
    {esp32_pinout} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
    {f} % Обтекание (без обтекания)
    {h} % Положение рисунка (см. figure из пакета float)
    {0.66\textwidth} % Ширина рисунка
    {Выводы MK ESP32} % Подпись рисунка


    \subsubsection{Классификация выводов}
    Выводы ESP32 можно классифицировать по нескольким критериям:

    По назначению:
    \begin{itemize}
        \item[-] GPIO (General Purpose Input/Output): Используются для общего назначения, могут быть настроены как входы или выходы;
        \item[-] ADC (Analog to Digital Converter): Позволяют считывать аналоговые сигналы и преобразовывать их в цифровые значения;
        \item[-] PWM (Pulse Width Modulation): Используются для управления мощностью, например, в светодиодах или моторах;
        \item[-] I2C, SPI, UART: Интерфейсы для связи с другими устройствами;
    \end{itemize}

    По функциональности:
    \begin{itemize}
        \item[-] цифровые выводы: Поддерживают только два состояния (высокий и низкий уровень);
        \item[-] аналоговые выводы: Позволяют считывать диапазон значений, что делает их полезными для работы с датчиками.
    \end{itemize}

    По уровню напряжения:
    \begin{itemize}
        \item[-] Логические уровни: Поддерживают уровни 0 и 1, что соответствует 0 В и 3.3 В соответственно.
    \end{itemize}

    \subsubsection{Назначение выводов}
    Выводы микроконтроллера ESP32 предназначены для выполнения задач в рамках проектирования и разработки систем управления. Они позволяют:
    \begin{itemize}
        \item[-] подключать и управлять внешними устройствами (датчиками, исполнительными механизмами).
        \item[-] обеспечивать связь между микроконтроллером и другими компонентами системы.
        \item[-] реализовывать функции управления и мониторинга в реальном времени.
    \end{itemize}


    \subsection{Описание датчика влажности и темературы воздуха DHT-11}
    DHT-11\cite{DHT11TemperatureHumiditySensor} — это цифровой датчик, предназначенный для измерения температуры и влажности воздуха. Он используется в проектах, связанных с микропроцессорными системами, благодаря своей простоте в использовании и доступной цене.

    \subsubsection{Внутреннее устройство}
    Сенсорная часть: Внутри датчика находятся два основных сенсора — один для измерения температуры, другой для влажности. Сенсор влажности основан на изменении электрического сопротивления, которое зависит от уровня влажности. Сенсор температуры использует термистор, который изменяет свое сопротивление в зависимости от температуры.

    Аналогово-цифровой преобразователь (АЦП): Этот компонент преобразует аналоговые сигналы, полученные от сенсоров, в цифровые данные, которые могут быть обработаны микроконтроллером.

    Микроконтроллер: Внутренний микроконтроллер управляет работой датчика, обрабатывает данные и отправляет их через однопроводной интерфейс.

    Корпус: Датчик защищен пластиковым корпусом, который обеспечивает защиту от внешних воздействий и позволяет воздуху свободно проходить к сенсорам.

    \subsubsection{Принцип работы}
    Измерение влажности: Сенсор влажности использует гигроскопический материал, который изменяет свое электрическое сопротивление в зависимости от уровня влажности. Когда влажность увеличивается, материал поглощает воду, что приводит к изменению его сопротивления. Это изменение фиксируется и преобразуется в цифровой сигнал.

    Измерение температуры: Сенсор температуры использует термистор, который изменяет свое сопротивление в зависимости от температуры окружающей среды. Изменение температуры приводит к изменению сопротивления термистора, что также фиксируется и преобразуется в цифровой сигнал.

    Передача данных: После обработки данных внутренним микроконтроллером, информация о температуре и влажности передается через однопроводной интерфейс к микроконтроллеру, который может использовать эти данные для дальнейшей обработки или отображения.


    \subsection{Описание ультразвукового датчика HC-SR04}
    HC-SR04\cite{UltrazvukovoyDalnomerHCSR04} — это ультразвуковой датчик расстояния, который используется для измерения расстояния до объектов с помощью ультразвуковых волн. Он применяется в  системах автоматизации и проектах, где требуется определение расстояния до препятствий.

    \subsubsection{Внутреннее устройство}
    \begin{itemize}
        \item ультразвуковые излучатели: Датчик имеет два ультразвуковых излучателя — один для передачи ультразвуковых волн, другой для их приема. Излучатель генерирует звуковые волны с частотой около 40 кГц.
        \item микроконтроллер: внутренний микроконтроллер управляет работой датчика, генерирует сигналы для излучателя и обрабатывает возвращенные сигналы от приемника
        \item приемник: приемник фиксирует отраженные ультразвуковые волны, которые возвращаются от объектов, находящихся на определенном расстоянии
    \end{itemize}

    \subsubsection{Принцип работы}
    Принцип работы основан на использовании ультразвуковых волн для измерения расстояния:
    \begin{enumerate}
        \item Генерация сигнала: При подаче сигнала на триггерный вход датчика, внутренний микроконтроллер активирует ультразвуковой излучатель, который генерирует короткий импульс ультразвуковых волн.
        \item Отражение сигнала: Ультразвуковые волны распространяются в воздухе и отражаются от ближайшего объекта.
        \item Прием сигнала: Отраженные волны возвращаются к датчику и фиксируются приемником. В этот момент микроконтроллер начинает отсчитывать время, прошедшее с момента отправки сигнала до его получения.
        \item Расчет расстояния: После получения сигнала микроконтроллер останавливает отсчет времени и рассчитывает расстояние до объекта, используя формулу: $$\text{Расстояние} = \frac{\text{Скорость звука} \times \text{Время}}{2}$$. Скорость звука в воздухе составляет примерно 343 метра в секунду при температуре 20 °C. Деление на 2 необходимо, так как время учитывает путь туда и обратно.
    \end{enumerate}

    \subsection{Описание датчика влажности почвы YL-69}
    YL-69\cite{GuideSoilMoisture2016} — это датчик влажности почвы, который используется для измерения уровня влажности в почве. Он применяется в системах автоматического полива, агрономии и проектах, где необходимо контролировать состояние почвы.

    \subsubsection{Внутреннее устройство}
    \begin{itemize}
        \item электроды: Датчик имеет два металлических электрода, которые погружаются в почву и измеряют её проводимость, что позволяет определить уровень влажности.
        \item аналоговый выход: YL-69 генерирует аналоговый сигнал, который пропорционален уровню влажности почвы. Этот сигнал можно подключить к аналоговому входу микроконтроллера для дальнейшей обработки.
        \item защитный корпус: Датчик имеет защитный корпус, который предотвращает коррозию и повреждение электрических компонентов при контакте с почвой.
    \end{itemize}

    \subsubsection{Принцип работы}
    Принцип работы основан на измерении проводимости почвы:
    \begin{enumerate}
        \item Измерение проводимости: Когда электроды датчика погружаются в почву, через них проходит небольшой электрический ток. Уровень проводимости зависит от содержания влаги в почве.
        \item Генерация сигнала: На основе измеренной проводимости датчик генерирует аналоговый сигнал, который пропорционален уровню влажности. Чем выше влажность, тем ниже сопротивление почвы и выше проводимость.
        \item Передача данных: Аналоговый сигнал передается на микроконтроллер, который может использовать его для анализа состояния почвы и принятия решений о необходимости полива.
    \end{enumerate}

    Вот описание датчика TEMT6000:

    \subsection{Описание датчика TEMT6000}
    TEMT6000\cite{adminDatchikOsveshchennostiTEMT60002022} — это фотодатчик, который используется для измерения уровня освещенности в окружающей среде. Он применяется в системах автоматического управления освещением, метеорологии и проектах, где необходимо контролировать уровень света.

    \subsubsection{Внутреннее устройство}
    \begin{itemize}
        \item фотосенсор: Датчик содержит фотосенсор, который реагирует на уровень освещения и преобразует световую энергию в электрический сигнал.
        \item аналоговый выход: TEMT6000 генерирует аналоговый сигнал, пропорциональный уровню освещенности. Этот сигнал можно подключить к аналоговому входу микроконтроллера для дальнейшей обработки.
        \item защитный корпус: Датчик имеет защитный корпус, который обеспечивает защиту от внешних воздействий и позволяет устанавливать его в различных условиях.
    \end{itemize}

    \subsubsection{Принцип работы}
    Принцип работы основан на фотопроводимости:
    \begin{enumerate}
        \item Поглощение света: Когда свет попадает на фотосенсор, он поглощает световую энергию, что приводит к изменению его проводимости.
        \item Генерация сигнала: На основе уровня освещения фотосенсор генерирует аналоговый сигнал, который пропорционален интенсивности света. Чем больше света, тем ниже сопротивление и выше выходной сигнал.
        \item Передача данных: Аналоговый сигнал передается на микроконтроллер, который может использовать его для анализа уровня освещенности и принятия решений о необходимости изменения условий освещения.
    \end{enumerate}

    \subsection{Функциональная схема}
    На основе вышеописанных сведений была спроектирована функциональная схема разрабатываемой системы,
    показанная на рисунке ~\ref{img:functional} в приложении Б.

    
    \section{Проектирование принципиальной схемы}
    
    \subsubsection{Разъем программатора}
    Разъём программатора CH340 с USB Type-C используется для подключения к микроконтроллеру через интерфейс USB.
    CH340 — это USB-UART преобразователь, который позволяет компьютеру взаимодействовать с микроконтроллером через последовательный интерфейс.

    Основные выводы и их функции:
    \begin{enumerate}
        \item VCC: Питание для микроконтроллера. Обычно 3.3V или 5V в зависимости от модели CH340
        \item GND: Общий провод (земля)
        \item TXD (Transmit Data): Передача данных от CH340 к микроконтроллеру
        \item RXD (Receive Data): Приём данных от микроконтроллера к CH340
        \item DTR (Data Terminal Ready): Используется для управления сигналом RESET микроконтроллера, чтобы ввести его в режим программирования
        \item RTS (Request to Send): Может использоваться для дополнительных функций управления
    \end{enumerate}

    Подключение через USB Type-C обеспечивает универсальный интерфейс,
    который поддерживает реверсивное подключение и высокую скорость передачи данных.

    \subsubsection{Подключение цепи питания}

    Для работы схемы с ESP32 необходимо подать напряжение, для этого будет использован блок питания с разъёмом USB,
    имеющий следующие технические характеристики:
    \begin{itemize}
        \item Выходной ток: до 3 А
        \item Выходное напряжение: 5 В
        \item Входное напряжение: 100 – 240 В (универсальный диапазон)
    \end{itemize}

    Для подключения питания к ESP32 будет использован стандартный USB кабель,
    который подключается к USB type-c разъёму на плате ESP32.

    Основные элементы подключения:
    \begin{enumerate}
        \item Блок питания: обеспечивает стабильное напряжение 5 В и ток до 3 А, что достаточно для питания ESP32 и
        подключенных к нему периферийных устройств.
        \item Кабель USB:
        \begin{itemize}
            \item Один конец подключается к USB разъёму блока питания
            \item Другой конец подключается к USB разъёму на плате ESP32
        \end{itemize}
        \item ESP32: Питание подаётся через USB разъём, который обеспечивает подключение к VCC (5V) и GND (земля) на плате ESP32.
    \end{enumerate}

    \subsubsection{Расчет сопротивления резисторов}\label{subsubsec:resistence}

    Резисторы предназначены, чтобы уменьшить значение тока, подаваемого на устройство.
    В резисторы установлены перед светодиодом и со стороны базы транзистора.

	Сначала определим сопротивление резистора, который предназначен для ограничения величины тока, протекающего через светодиод.
    $R_{k} = \frac{U_R}{I}  = \frac{2,1}{0,02} = 105$ Ом, где $U_R$ – напряжение питания на резисторе, $I$ – сила протекающего тока.

    Ближайшие стандарты – это 100 Ом и 110 Ом.
    Выбран будет резистор с большим номиналом, то есть 110 Ом – CF-100.

	Напряжение на резисторе рассчитывается по формуле:
        UR = UK - ΔUVD - ΔUK = 5 - 2,5 - 0,4 = 2,1 В, где UK – напряжение питания;
    ΔUVD – напряжение светодиода;
	ΔUK – падение напряжение на переходе коллектор-эмиттер.

	Ток, протекающий через светодиод, снизился: Iк=UR= 2,1110 = 0,019 А = 19 мА

	Для определения резистора со стороны базы, посчитаем ток базы.
    I = $I_{k}$ = 0,019200 = 0,000095 мкА, где Iк – ток коллектора, равный 0,019А;
	β – коэффициент усиления биполярного транзистора, для модели J3Y равный 200(в даташите он варьрируется от 120 до 350).

    $R_{Б}$ = $\frac{U}{I} = \frac{2,1}{0,000095} = 22105 $ Ом = 22,1 кОм
    Ближайшие стандарты – это 20 кОм и 25 кОм.
    Выбран будет резистор с большим номиналом, то есть 25 кОм – MO-100.

    \subsubsection{Расчет потребляемой мощности}

    Потребляемая мощность – это мощность, потребляемая интегральной схемой, которая работает в заданном режиме соответствующего источника питания.
	Чтобы рассчитать суммарную мощность, рассчитаем мощность каждого элемента.
    На все микросхемы подается напряжение +3.3В.
    Мощность, потребляемая один устройством, в статическом режиме, рассчитывается формулой.
    \[P = U * I\]
	где U – напряжение питания (В);

	I – ток потребления микросхемы (мА).

    Также в схеме присутствуют резисторы и транзисторы.
    Мощность для резисторов рассчитывается по формуле:
    \[Р = I^2 * R\]
	где R – сопротивление резистора;

    I – ток, проходящий через резистор.

    Для транзисторов по формуле:
    \[P = U * I\]
	где U – напряжение коллектор-эмиттер;

	I – ток коллектора (он был рассчитан в разделе ~\ref{subsubsec:resistence}).

	Расчет потребляемого напряжения для каждой микросхемы показан в таблице ~\ref{tab:power_component_table}.

%    TODO: вставить таблицу и посчитать транзисоры и тд

    \begin{table}[h]
        \caption{Потребляемая мощность}
        \label{tab:power_component_table}
        \begin{sloppypar}
            \centering
            \begin{tabularx}{\textwidth}{ | >{\raggedright\arraybackslash}X | >{\raggedright\arraybackslash}X |}
                \hline
                Микросхема & Ток потребления, мА & Потребляемая мощность, мВт & Количество устройств & Суммарная потребляемая мощность, мВт \\
                \hline
                ESP-32 & 200 & 660 & 1 & 660 \\
                \hline
                CH340C & 10 & 33 & 1 & 33 \\
                \hline
                 &  &  & 1 &  \\


                \hline
            \end{tabularx}
            \centering
        \end{sloppypar}
    \end{table}


    Также в схеме используются 28 резисторов CF-100 и МО-100 с номиналом 110 и 25 кОм соответственно,
    2 резистора CF-25 с номиналом 1 кОм, и 28 транзисторов 2N2222.

    \subsubsection{Построение принципиальной схемы}

    На основе всех вышеописанных сведений была спроектирована принципиальная схема разрабатываемой системы,
    показанная на рисунке ~\ref{img:principal} и в приложении Б.




    \section{Описание алгоритмов основных программных процедур}

    \subsection{Главная процедура программы}

    \includeimage
        {main_procedure_algo} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
        {f} % Обтекание (без обтекания)
        {h} % Положение рисунка (см. figure из пакета float)
        {0.66\textwidth} % Ширина рисунка
        {Главная процедурая программы} % Подпись рисунка

    \chapter{Технологическая часть}

    \section{Моделирование и отладка системы на макетной плате}

    Для разработки проекта использоваcь среда CLion \cite{ESPIDFCLion} от компании JetBrains, позволяющая разрабатывать программные продукты на языках C/C++.
    Для программирования и отладки на плате esp использовался фреймворк IDF-ESP \cite{GetStartedESP32}.

    При разработке в среде CLion с использованием плагина ESP-IDF для микроконтроллеров ESP32, процесс выглядит следующим образом:

    \begin{itemize}
        \item[-] конфигурация проекта: основной конфигурационный файл проекта — sdkconfig.
        В него необходимо вручную добавлять переменные окружения, такие как настройки Wi-Fi, поскольку они не импортируются автоматически.
        Это позволяет управлять параметрами проекта.
        \item[-] локальные конфигурации: файлы Kconfig.projbuild не импортируются автоматически в проект,
        поэтому их нужно обрабатывать вручную, если требуется специфическая конфигурация для отдельных компонентов.
        \item[-] компиляция и прошивка: для прошивки платы используется команда flash, в которой необходимо указать ELF-файл,
        полученный после компиляции.
        Это позволяет загружать скомпилированную программу непосредственно на микроконтроллер.(см. рисунок ~\ref{img:flash_esp32)}
        \item[-] отладка и тестирование: ESP-IDF предоставляет возможность отладки в виде запуска
        исполняемого файла monitor, сделать это можно с помощью скрипта. (см. листинг ~\ref{lst:flash_esp32)).
        Выйти из режима отладки можно с помощью комбинации `CTRL` + `]`
        Благодаря этой функции можно в реальном времени отслеживать логи, которые образуются
        в процессе выполнения программы.
        \item[-] интеграция с внешними устройствами: Для взаимодействия с внешними устройствами, такими как датчики или
        дисплеи, используются стандартные библиотеки ESP-IDF, которые поддерживают протоколы SPI, I2C и UART.
    \end{itemize}

    \includeimage
        {flash_esp32} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
        {f} % Обтекание (без обтекания)
        {h} % Положение рисунка (см. figure из пакета float)
        {0.66\textwidth} % Ширина рисунка
        {Процесс разработки и прошивки платы ESP} % Подпись рисунка


    После сборки схемы, программа была прошита и протестирована.
    Итоговый результат можете видеть на рисунке ~\ref{img:workplace} и ~\ref{img:maket}.
    В итоговой конструкции макетная плата находится сверху над комнатным растением, там же расположены датчики
    освещённости, температуры и влажности воздуха.
    Ультразвуковой датчик прикреплён с обратной стороны констукции, высота горшка и высота констукции была заранее высчитана и учитывается при подсчёте роста растения.
    Датчик влажности почвы расположен в почве горшка.

    \includeimage
        {workplace} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
        {f} % Обтекание (без обтекания)
        {h} % Положение рисунка (см. figure из пакета float)
        {0.66\textwidth} % Ширина рисунка
        {Общая фотография комнатного растения, макетной платы и выводимых метрик} % Подпись рисунка

    \includeimage
        {maket} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
        {f} % Обтекание (без обтекания)
        {h} % Положение рисунка (см. figure из пакета float)
        {0.66\textwidth} % Ширина рисунка
        {Более детальная фотография макетной платы} % Подпись рисунка

    \section{Разработка серверной части системы мониторинга}
    Для разработки серверной части приложения был арендован VPS(Virtual private server) сервер по \href{http://vm4481772.25ssd.had.wf:3000/d/ce3f4anwhavpce/plant-monitoring?from=now-15m&to=now&timezone=browser}{адресу}.

    \subsection{MQTT-брокер}
    Брокер MQTT — главный узел (серверное ПО) для подключения IoT устройств и обмену сообщений между ними.

    Топик - канал или адрес, по которому сообщения отправляются и принимаются.

    На сервер был установлен MQTT-брокер mosquitto \cite{ndunguInstallMosquittoMQTT}  c помощью следующих команд:

    \subsubsection{Установка}
    \includelisting
        {scripts/install-mqtt-broker.sh} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {shell}
        {Исходный код установки и запука mosquitto} % Подпись листинга

    \subsubsection{Отправка сообщений}
    На брокер не была добавлена авторизация, так как проект является академическим и технические требования при этом не нарушаются.
    Для отправки валидного сообщения нужно указать хост и порт, на который происходит отправка сообщений,
    сообщение в формате json и также указать топик, к которому идёт отправка.
    \includelisting
        {scripts/send-to-mqtt-broker.sh} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {shell}
        {Исходный код отправки сообзения на брокер mosquitto} % Подпись листинга
    
    \subsubsection{Клиент MQTT}
    Для валидирования доставки отправки метрик можно воспользоваться MQTT-Explorer ~\cite{nordquistMQTTExplorer}.
    Настройки MQTT-explorer:
    \includeimage
        {mqtt-explorer} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
        {f} % Обтекание (без обтекания)
        {h} % Положение рисунка (см. figure из пакета float)
        {0.66\textwidth} % Ширина рисунка
        {Настройки MQTT-explorer} % Подпись рисунка

    Во вкладке advanced необходимо подписаться на топик \texttt{/esp32/plant\_monitoring/metrics} и удалите топик SYS.

    \subsection{Деплой приложения}

    Как было упомянуто в ~\ref{sec:arch} на сервере с помощью cli утилиты docker-compose были запущены контейнеры следующих приложений:
    \begin{itemize}
        \item mqtt-exporter
        \item prometheus
        \item alertmanager
        \item grafana
    \end{itemize}

    Docker Compose — это инструмент для определения и запуска многоконтейнерных приложений с использованием Docker.
    Он позволяет описывать конфигурацию приложения в одном файле (обычно docker-compose.yml), где можно указать,
    какие контейнеры нужны, их настройки, зависимости и сети.

    \subsection{Prometheus}
    Из MQTT-брокер c помощью утилиты mqtt-exporter метрики попадают в Prometheus.
    Prometheus обладает базовым функционалом визуализации метрик, поэтому для отображения было выбрано приложение Grafana.

    \includeimage
        {prometheus_screenshot}
        {f}
        {h}
        {0.8\textwidth}
        {Скриншот приложения Prometheus, запущенного на сервере}


    \subsection{Grafana}

    Для визуализации метрик Grafana использовался язык PromQL \cite{styopaChtoTakoePromQL2023}.

    PromQL (Prometheus Query Language) — это язык запросов, используемый в системе мониторинга Prometheus для извлечения
    и обработки данных о метриках.
    Он позволяет пользователям формулировать запросы к временным рядам данных, собранным Prometheus,
    и выполнять операции, такие как агрегация, фильтрация и математические вычисления.

    В ~\ref{sec:diff-plant-estimate} была выведена формула оценки общего состояния растения,
    для визуализации этой метрики в grafana было принято решение брать среднее взвешенное значение показателей
    датчиков за последние 5 минут.

    \includelisting
        {grafana/common_estimate.promql} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {promql}
        {Запрос общей оценки состояния растения в языке PromQL} % Подпись листинга

    Для большей выразительности помимо текущего состояния метрик на борду была добавлена динамика метрик во времени и
    график алертов.

    \includeimage
        {grafana_dashboard}
        {f}
        {h}
        {0.8\textwidth}
        {Скриншот дэшборда Grafana, отображающий метрики растения}

    \subsection{AlertManager}
    Alertmanager — это компонент системы мониторинга Prometheus, предназначенный для управления оповещениями.
    Он обрабатывает уведомления, которые генерируются Prometheus на основе заданных правил, и управляет их отправкой
    в различные каналы (например, электронная почта или мессенджер).

    В качестве канала оповещения был выбран Telegram, так как он является наиболее популярным мессенджером в мире
    и имеет просто и понятное API.

    Оповещения были настроены таким образом, чтобы алерт вызывался, если растение находится
    в неблагоприятных условиях в течение определенного времени.
    Рассмотрим на одном из правил алертинга, которое задавалось в файле alerts.rules.
    (см. листинг ~\ref{lst:alertmanager/temprature_rule.rules})

    \includelisting
        {alertmanager/temprature_rule.rules}
        {rules}
        {Правило определения экстремальной температуры в окружающей среде}

    Если датчик в течение 20 минут фиксирует температуру большую 40 или меньшую 10, то алерт срабатывает
    и ему присваивается критический уровень.

    Настройка формата сообщения настраивалась с помощью шаблона - формат .tmpl.
    Шаблон был взят из открытых источников ~\cite{TelegramMessageTemplate}.
    Тип получателя - канал, в который будут отправляться оповещения, настраивается с помощью .yaml файла.
    (см. листинг ~\ref{lst:alertmanager/alertmanager.yml}).
    Для использование бота, нужно определить chat\_id и создать токен ~\cite{262588213843476HowGetTelegram}.

    \includelisting
        {alertmanager/alertmanager.yml} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {yml}
        {Настройка типа получателя в виде бота в Telegram} % Подпись листинга

    Бот будет присылать сообщение в чат после интервала времени group\_interval.
    И далее слать их повторно, каждые repeat\_interval, пока алерт не будет закрыт.
    После закрытия алерта также будет прислано сообщение. (см. рисунок ~\ref{img:telegram})

    \includeimage
        {telegram}
        {f}
        {h}
        {0.66\textwidth}
        {Оповещений о критическом состоянии растения и уведомление о решении проблемы}


    \chapter*{ЗАКЛЮЧЕНИЕ}
    \addcontentsline{toc}{chapter}{ЗАКЛЮЧЕНИЕ}

    В ходе выполнения курсового проекта был спроектирована система мониторинга состояния комнатного растения.
    Система работает на основе МК серии ESP – ESP32.
    Устройство разработано в соответствии с ТЗ.

    В результате проектирования были разработаны принципиальная и функциональная электрические схемы для аппаратной части устройства. Код программы, написанный на языках C/С++, отлажен, протестирован, была собрана и прошита принципиальная схема, вывод метрик осузествляется на удалённый сервер.

    \makebibliography

    \begin{appendices}
        \chapter{}
        \includelistingpretty
        {main/main.cpp} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код файла - main.cpp} % Подпись листинга

        % Container
        \includelistingpretty
        {main/internal/container.cpp} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код файла реализации класса контейнера  - containter.cpp} % Подпись листинга
        \includelistingpretty
        {main/internal/container.h} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код заголовочного файла класса контейнера - containter.h} % Подпись листинга

        % DHT-11
        \includelistingpretty
        {components/dht11/include/dht11.h} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код заголовочного файла класса датчика dht11 - dht11.h} % Подпись листинга

        \includelistingpretty
        {components/dht11/dht11.cpp} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код реализации класса датчика dht11 - dht11.cpp} % Подпись листинга

        % HC-SR04
        \includelistingpretty
        {components/hc-sr04/include/hc-sr04.h} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код заголовочного файла класса датчика hc-sr04 - hc-sr04.h} % Подпись листинга

        \includelistingpretty
        {components/hc-sr04/hc-sr04.cpp} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код реализации класса датчика hc-sr04 - hc-sr04.cpp} % Подпись листинга

        % HC-SR04
        \includelistingpretty
        {components/hc-sr04/include/hc-sr04.h} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код заголовочного файла класса датчика hc-sr04 - hc-sr04.h} % Подпись листинга

        \includelistingpretty
        {components/hc-sr04/hc-sr04.cpp} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код реализации класса датчика hc-sr04 - hc-sr04.cpp} % Подпись листинга

        % TEMT6000
        \includelistingpretty
        {components/temt6000/include/temt6000.h} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код заголовочного файла класса датчика temt6000 - temt6000.h} % Подпись листинга

        \includelistingpretty
        {components/temt6000/temt6000.cpp} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код реализации класса датчика temt6000 - temt6000.cpp} % Подпись листинга


        % YL-69
        \includelistingpretty
        {components/yl-69/include/yl69.h} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код заголовочного файла класса датчика yl-69 - yl69.h} % Подпись листинга

        \includelistingpretty
        {components/yl-69/yl69.cpp} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код реализации класса датчика yl-69 - yl69.cpp} % Подпись листинга


        % Wi-Fi
        \includelistingpretty
        {components/wifi-connection/include/wifi.h} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c}
        {Исходный код заголовочного файла инициализации Wi-Fi - wifi.h} % Подпись листинга

        \includelistingpretty
        {components/wifi-connection/wifi.c} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c}
        {Исходный код реализации инициализации Wi-Fi - wi-fi.c} % Подпись листинга

        % Wi-Fi
        \includelistingpretty
        {components/wifi-connection/include/wifi.h} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c}
        {Исходный код заголовочного файла инициализации Wi-Fi - wifi.h} % Подпись листинга

        \includelistingpretty
        {components/wifi-connection/wifi.c} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c}
        {Исходный код реализации инициализации Wi-Fi - wi-fi.c} % Подпись листинга


        % MQTT
        \includelistingpretty
        {components/mqtt-connection/include/mqtt.h} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c}
        {Исходный код заголовочного файла клиента MQTT - mqtt.h} % Подпись листинга

        \includelistingpretty
        {components/mqtt-connection/include/mqtt.hh} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код заголовочного файла клиента MQTT - mqtt.h} % Подпись листинга


        \includelistingpretty
        {components/mqtt-connection/mqtt.c} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c}
        {Исходный код заголовочного файла клиента MQTT - mqtt.c} % Подпись листинга

        \includelistingpretty
        {components/mqtt-connection/mqtt.cc} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
        {c++}
        {Исходный код файла реализации клиента MQTT - mqtt.cc} % Подпись листинга

        \chapter{}
            {
                \centering
                Графическая часть

                На 2 листах

                Электрическая схема функциональная

                Электрическая схема принципиальная

            }
\end{appendices}
\end{document}
